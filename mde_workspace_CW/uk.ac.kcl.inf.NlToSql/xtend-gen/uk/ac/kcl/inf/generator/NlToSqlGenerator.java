/**
 * generated by Xtext 2.25.0
 */
package uk.ac.kcl.inf.generator;

import java.util.Arrays;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IntegerRange;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import uk.ac.kcl.inf.nlToSql.AccountingSpeech;
import uk.ac.kcl.inf.nlToSql.Column;
import uk.ac.kcl.inf.nlToSql.ColumnReference;
import uk.ac.kcl.inf.nlToSql.Comparison;
import uk.ac.kcl.inf.nlToSql.ComparisonOperatorString;
import uk.ac.kcl.inf.nlToSql.Condition;
import uk.ac.kcl.inf.nlToSql.CreateTableStatement;
import uk.ac.kcl.inf.nlToSql.Datatype;
import uk.ac.kcl.inf.nlToSql.DeleteStatement;
import uk.ac.kcl.inf.nlToSql.InsertStatement;
import uk.ac.kcl.inf.nlToSql.LogicExpressions;
import uk.ac.kcl.inf.nlToSql.SelectColumnsList;
import uk.ac.kcl.inf.nlToSql.SelectStatement;
import uk.ac.kcl.inf.nlToSql.SelectTable;
import uk.ac.kcl.inf.nlToSql.SelectTablesList;
import uk.ac.kcl.inf.nlToSql.Statement;
import uk.ac.kcl.inf.nlToSql.Table;
import uk.ac.kcl.inf.nlToSql.UpdateItem;
import uk.ac.kcl.inf.nlToSql.UpdateStatement;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class NlToSqlGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    EObject _head = IterableExtensions.<EObject>head(resource.getContents());
    final AccountingSpeech model = ((AccountingSpeech) _head);
    final String className = this.deriveClassName(resource);
    fsa.generateFile((className + ".sql"), this.doGenerateClass(model, className));
  }
  
  public CharSequence doGenerateClass(final AccountingSpeech program, final String string) {
    StringConcatenation _builder = new StringConcatenation();
    final Function1<Statement, CharSequence> _function = (Statement it) -> {
      return this.generateSQLStatement(it);
    };
    String _join = IterableExtensions.join(ListExtensions.<Statement, CharSequence>map(program.getStatements(), _function), "\n");
    _builder.append(_join);
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected String _generateSQLStatement(final Statement statement) {
    StringConcatenation _builder = new StringConcatenation();
    return _builder.toString();
  }
  
  protected String _generateSQLStatement(final CreateTableStatement statement) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("CREATE TABLE ");
    String _firstUpper = StringExtensions.toFirstUpper(statement.getTable().getName());
    _builder.append(_firstUpper);
    _builder.append("(");
    _builder.newLineIfNotEmpty();
    {
      EList<Column> _columnItem = statement.getColumns().getColumnItem();
      for(final Column column : _columnItem) {
        _builder.append("    ");
        String _firstUpper_1 = StringExtensions.toFirstUpper(column.getName());
        _builder.append(_firstUpper_1, "    ");
        _builder.append(" ");
        CharSequence _sqlString = this.toSqlString(column.getType());
        _builder.append(_sqlString, "    ");
        _builder.append(",");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append(");");
    return _builder.toString();
  }
  
  protected String _generateSQLStatement(final SelectStatement statement) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("SELECT");
    {
      SelectColumnsList _columns = statement.getColumns();
      boolean _tripleEquals = (_columns == null);
      if (_tripleEquals) {
        _builder.append(" *\n");
      } else {
        {
          EList<ColumnReference> _selectColumn = statement.getColumns().getSelectColumn();
          for(final ColumnReference column : _selectColumn) {
            _builder.append(" ");
            String _firstUpper = StringExtensions.toFirstUpper(column.getColumn().getName());
            _builder.append(_firstUpper);
            {
              boolean _equals = column.equals(IterableExtensions.<ColumnReference>last(statement.getColumns().getSelectColumn()));
              boolean _not = (!_equals);
              if (_not) {
                _builder.append(",");
              }
            }
          }
        }
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.append("FROM ");
    final Function1<Table, String> _function = (Table it) -> {
      return StringExtensions.toFirstUpper(it.getName());
    };
    String _join = IterableExtensions.join(ListExtensions.<Table, String>map(statement.getTables().getSelectTable(), _function), ", ");
    _builder.append(_join);
    _builder.newLineIfNotEmpty();
    {
      LogicExpressions _condition = statement.getCondition();
      boolean _tripleNotEquals = (_condition != null);
      if (_tripleNotEquals) {
        _builder.append("WHERE ");
        String _generateConditionExpression = this.generateConditionExpression(statement.getCondition());
        _builder.append(_generateConditionExpression);
      }
    }
    _builder.newLineIfNotEmpty();
    {
      SelectColumnsList _group = statement.getGroup();
      boolean _tripleEquals_1 = (_group == null);
      if (_tripleEquals_1) {
        _builder.append(";");
      } else {
        _builder.append("GROUP BY ");
        final Function1<ColumnReference, String> _function_1 = (ColumnReference it) -> {
          return StringExtensions.toFirstUpper(it.getColumn().getName());
        };
        String _join_1 = IterableExtensions.join(ListExtensions.<ColumnReference, String>map(statement.getGroup().getSelectColumn(), _function_1), ", ");
        _builder.append(_join_1);
        _builder.append(";");
      }
    }
    _builder.newLineIfNotEmpty();
    return _builder.toString();
  }
  
  protected CharSequence _generateSQLStatement(final InsertStatement statement) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("INSERT INTO ");
    String _firstUpper = StringExtensions.toFirstUpper(statement.getTable().getTable().getName());
    _builder.append(_firstUpper);
    _builder.append(" (");
    {
      EList<ColumnReference> _selectColumn = statement.getColumns().getSelectColumn();
      for(final ColumnReference column : _selectColumn) {
        String _firstUpper_1 = StringExtensions.toFirstUpper(column.getColumn().getName());
        _builder.append(_firstUpper_1);
        {
          boolean _equals = column.equals(IterableExtensions.<ColumnReference>last(statement.getColumns().getSelectColumn()));
          boolean _not = (!_equals);
          if (_not) {
            _builder.append(", ");
          }
        }
      }
    }
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    _builder.append("VALUES (");
    {
      EList<String> _valueList = statement.getValues().getValueList();
      for(final String value : _valueList) {
        _builder.append(value);
        {
          boolean _equals_1 = value.equals(IterableExtensions.<String>last(statement.getValues().getValueList()));
          boolean _not_1 = (!_equals_1);
          if (_not_1) {
            _builder.append(", ");
          }
        }
      }
    }
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    _builder.append(";");
    _builder.newLine();
    return _builder;
  }
  
  protected CharSequence _generateSQLStatement(final UpdateStatement statement) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("UPDATE ");
    String _firstUpper = StringExtensions.toFirstUpper(statement.getTable().getTable().getName());
    _builder.append(_firstUpper);
    _builder.newLineIfNotEmpty();
    _builder.append("SET ");
    {
      EList<UpdateItem> _updateItem = statement.getUpdates().getUpdateItem();
      for(final UpdateItem update : _updateItem) {
        String _firstUpper_1 = StringExtensions.toFirstUpper(update.getColumn().getColumn().getName());
        _builder.append(_firstUpper_1);
        _builder.append(" = ");
        String _value = update.getValue();
        _builder.append(_value);
        {
          boolean _equals = update.equals(IterableExtensions.<UpdateItem>last(statement.getUpdates().getUpdateItem()));
          boolean _not = (!_equals);
          if (_not) {
            _builder.append(", ");
          }
        }
      }
    }
    _builder.newLineIfNotEmpty();
    {
      LogicExpressions _condition = statement.getCondition();
      boolean _tripleNotEquals = (_condition != null);
      if (_tripleNotEquals) {
        _builder.append("WHERE ");
        String _generateConditionExpression = this.generateConditionExpression(statement.getCondition());
        _builder.append(_generateConditionExpression);
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.append(";");
    _builder.newLine();
    return _builder;
  }
  
  protected CharSequence _generateSQLStatement(final DeleteStatement statement) {
    StringConcatenation _builder = new StringConcatenation();
    {
      SelectTable _tableToEmpty = statement.getTableToEmpty();
      boolean _tripleNotEquals = (_tableToEmpty != null);
      if (_tripleNotEquals) {
        _builder.append("DELETE FROM ");
        String _firstUpper = StringExtensions.toFirstUpper(statement.getTableToEmpty().getTable().getName());
        _builder.append(_firstUpper);
      } else {
        {
          SelectTablesList _tables = statement.getTables();
          boolean _tripleNotEquals_1 = (_tables != null);
          if (_tripleNotEquals_1) {
            _builder.append("DROP TABLE ");
            final Function1<Table, String> _function = (Table it) -> {
              return StringExtensions.toFirstUpper(it.getName());
            };
            String _join = IterableExtensions.join(ListExtensions.<Table, String>map(statement.getTables().getSelectTable(), _function), ",");
            _builder.append(_join);
          } else {
            _builder.append("DELETE FROM ");
            String _firstUpper_1 = StringExtensions.toFirstUpper(statement.getTableToDelete().getTable().getName());
            _builder.append(_firstUpper_1);
            _builder.newLineIfNotEmpty();
            _builder.append("WHERE ");
            String _generateConditionExpression = this.generateConditionExpression(statement.getCondition());
            _builder.append(_generateConditionExpression);
          }
        }
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.append(";");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence toSqlString(final Datatype datatype) {
    StringConcatenation _builder = new StringConcatenation();
    String _switchResult = null;
    if (datatype != null) {
      switch (datatype) {
        case INTEGER:
          _switchResult = "INT";
          break;
        case STRING:
          _switchResult = "VARCHAR(255)";
          break;
        case DATE:
          _switchResult = "DATE";
          break;
        default:
          break;
      }
    }
    _builder.append(_switchResult);
    return _builder;
  }
  
  protected String _generateConditionExpression(final LogicExpressions expression) {
    StringConcatenation _builder = new StringConcatenation();
    return _builder.toString();
  }
  
  protected String _generateConditionExpression(final Condition expression) {
    StringConcatenation _builder = new StringConcatenation();
    String _generateConditionExpression = this.generateConditionExpression(expression.getLeft());
    _builder.append(_generateConditionExpression);
    {
      int _size = expression.getLogicOperator().size();
      int _minus = (_size - 1);
      IntegerRange _upTo = new IntegerRange(0, _minus);
      for(final Integer logicOperatorIndex : _upTo) {
        _builder.append(" ");
        String _get = expression.getLogicOperator().get((logicOperatorIndex).intValue());
        _builder.append(_get);
        _builder.append(" ");
        String _generateConditionExpression_1 = this.generateConditionExpression(expression.getRight().get((logicOperatorIndex).intValue()));
        _builder.append(_generateConditionExpression_1);
      }
    }
    return _builder.toString();
  }
  
  protected String _generateConditionExpression(final Comparison expression) {
    StringConcatenation _builder = new StringConcatenation();
    String _firstUpper = StringExtensions.toFirstUpper(expression.getLeftHandSide().getName());
    _builder.append(_firstUpper);
    _builder.append(" ");
    String _generateComparisonOperatorExpression = this.generateComparisonOperatorExpression(expression.getOperator());
    _builder.append(_generateComparisonOperatorExpression);
    _builder.append(" ");
    String _rightHandSide = expression.getRightHandSide();
    _builder.append(_rightHandSide);
    return _builder.toString();
  }
  
  public String generateComparisonOperatorExpression(final ComparisonOperatorString comparison) {
    StringConcatenation _builder = new StringConcatenation();
    String _switchResult = null;
    if (comparison != null) {
      switch (comparison) {
        case EQUAL_TO:
          _switchResult = "=";
          break;
        case LESS_THAN:
          _switchResult = "<";
          break;
        case GREATER_THAN:
          _switchResult = ">";
          break;
        case LESS_THAN_OR_EQUAL_TO:
          _switchResult = "<=";
          break;
        case GREATER_THEN_OR_EQUAL_TO:
          _switchResult = ">=";
          break;
        case NOT_EQUAL_TO:
          _switchResult = "<>";
          break;
        case EQUAL_TO_SIGN:
          _switchResult = "=";
          break;
        case GREATER_THAN_SIGN:
          _switchResult = ">";
          break;
        case GREATER_THEN_OR_EQUAL_TO_SIGN:
          _switchResult = ">=";
          break;
        case LESS_THAN_OR_EQUAL_TO_SIGN:
          _switchResult = "<=";
          break;
        case LESS_THAN_SIGN:
          _switchResult = "<=";
          break;
        case NOT_EQUAL_TO_SIGN:
          _switchResult = "<>";
          break;
        default:
          break;
      }
    }
    _builder.append(_switchResult);
    return _builder.toString();
  }
  
  public String deriveClassName(final Resource resource) {
    String _xblockexpression = null;
    {
      final String originalFileName = resource.getURI().lastSegment();
      String _firstUpper = StringExtensions.toFirstUpper(originalFileName.substring(0, originalFileName.indexOf(".")));
      _xblockexpression = (_firstUpper + "AccountingSpeech");
    }
    return _xblockexpression;
  }
  
  public String deriveTargetFileNameFor(final AccountingSpeech speech, final Resource resource) {
    return resource.getURI().appendFileExtension("sql").lastSegment();
  }
  
  public CharSequence generateSQLStatement(final Statement statement) {
    if (statement instanceof CreateTableStatement) {
      return _generateSQLStatement((CreateTableStatement)statement);
    } else if (statement instanceof DeleteStatement) {
      return _generateSQLStatement((DeleteStatement)statement);
    } else if (statement instanceof InsertStatement) {
      return _generateSQLStatement((InsertStatement)statement);
    } else if (statement instanceof SelectStatement) {
      return _generateSQLStatement((SelectStatement)statement);
    } else if (statement instanceof UpdateStatement) {
      return _generateSQLStatement((UpdateStatement)statement);
    } else if (statement != null) {
      return _generateSQLStatement(statement);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(statement).toString());
    }
  }
  
  public String generateConditionExpression(final LogicExpressions expression) {
    if (expression instanceof Comparison) {
      return _generateConditionExpression((Comparison)expression);
    } else if (expression instanceof Condition) {
      return _generateConditionExpression((Condition)expression);
    } else if (expression != null) {
      return _generateConditionExpression(expression);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(expression).toString());
    }
  }
}
