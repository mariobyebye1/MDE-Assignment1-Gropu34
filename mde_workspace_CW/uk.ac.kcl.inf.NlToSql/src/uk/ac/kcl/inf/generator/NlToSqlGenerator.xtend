/*
 * generated by Xtext 2.25.0
 */
package uk.ac.kcl.inf.generator
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.inf.nlToSql.AccountingSpeech
import uk.ac.kcl.inf.nlToSql.CreateTableStatement
import uk.ac.kcl.inf.nlToSql.Statement
import uk.ac.kcl.inf.nlToSql.Datatype
import uk.ac.kcl.inf.nlToSql.SelectStatement
import uk.ac.kcl.inf.nlToSql.InsertStatement
import uk.ac.kcl.inf.nlToSql.UpdateStatement
import uk.ac.kcl.inf.nlToSql.SelectTablesList
import uk.ac.kcl.inf.nlToSql.SelectColumnsList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class NlToSqlGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as AccountingSpeech
		
		val className = resource.deriveClassName
		fsa.generateFile(className + '.sql', model.doGenerateClass(className))
	}
	
	def doGenerateClass(AccountingSpeech program, String string) '''
		«program.statements.map[generateSQLStatement].join('\n')»
	'''

	dispatch def generateSQLStatement(Statement statement) ''''''
	
	dispatch def generateSQLStatement(CreateTableStatement statement) '''
    CREATE TABLE «statement.table.name.toFirstUpper»(
        «FOR column:statement.columns.columnItem»
            «column.name.toFirstUpper» «column.type.toSqlString»,
        «ENDFOR»
    );'''


	def toSqlString(Datatype datatype) '''
    «switch datatype {
        case Datatype.INTEGER: "INT"
        case Datatype.STRING: "VARCHAR(255)"
        case Datatype.DATE: "DATE"
    }»'''

	dispatch def generateSQLStatement(SelectStatement statement) '''
	SELECT
		«IF statement.columns.selectColumn.empty»*«ELSE»«FOR column : statement.columns.selectColumn»
			«column.column.name.toFirstUpper»
			«IF !column.equals(statement.columns.selectColumn.last)»,«ENDIF»
		«ENDFOR»«ENDIF»
	FROM «statement.tables.selectTable.map[name.toFirstUpper].join(', ')»
	«IF statement.condition != null»WHERE «statement.condition.generate»«ENDIF»
	'''
	
	dispatch def generateSQLStatement(InsertStatement statement) '''
	INSERT INTO «statement.table.table.name.toFirstUpper»
		(«FOR column : statement.columns.selectColumn»«column.column.name.toFirstUpper»«IF !column.equals(statement.columns.selectColumn.last)», «ENDIF»«ENDFOR»)
		VALUES
		(«FOR value : statement.values.valueList»«value.generate»«IF !value.equals(statement.values.valueList.last)», «ENDIF»«ENDFOR»)
	;
	'''
	
	dispatch def generateSQLStatement(UpdateStatement statement) '''
	UPDATE «statement.table.table.name.toFirstUpper»
	SET «FOR update : statement.updates.updateItem»
		«update.column.column.name.toFirstUpper» = «update.value.generate»
		«IF !update.equals(statement.updates.updateItem.last)», «ENDIF»
	«ENDFOR»
	«IF statement.condition != null»WHERE «statement.condition.generate»«ENDIF»
	;
	'''

	def deriveClassName(Resource resource) {
		val originalFileName = resource.URI.lastSegment
		originalFileName.substring(0,originalFileName.indexOf('.')).toFirstUpper + 'AccountingSpeech'
	}
	
	
	def deriveTargetFileNameFor(AccountingSpeech speech, Resource resource) {
		resource.URI.appendFileExtension('sql').lastSegment
	}
}
