/*
 * generated by Xtext 2.25.0
 */
package uk.ac.kcl.inf.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.inf.nlToSql.AccountingSpeech
import uk.ac.kcl.inf.nlToSql.Condition
import uk.ac.kcl.inf.nlToSql.CreateTableStatement
import uk.ac.kcl.inf.nlToSql.Datatype
import uk.ac.kcl.inf.nlToSql.InsertStatement
import uk.ac.kcl.inf.nlToSql.LogicExpressions
import uk.ac.kcl.inf.nlToSql.SelectStatement
import uk.ac.kcl.inf.nlToSql.Statement
import uk.ac.kcl.inf.nlToSql.UpdateStatement
import uk.ac.kcl.inf.nlToSql.Comparison
import uk.ac.kcl.inf.nlToSql.ComparisonOperatorString
import uk.ac.kcl.inf.nlToSql.DeleteStatement
import org.eclipse.emf.common.util.EList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class NlToSqlGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as AccountingSpeech
		
		val className = resource.deriveClassName
		fsa.generateFile(className + '.sql', model.doGenerateClass(className))
	}
	
	def doGenerateClass(AccountingSpeech program, String string) '''
	«program.statements.sort.map[generateSQLStatement].join('\n')»
	'''

	private def sort(EList<Statement> statements){
		val createTableStatements= statements.reject(CreateTableStatement).toList
		val newList = statements.filter(CreateTableStatement).toList
		createTableStatements.addAll(newList)
		createTableStatements.reverse
	}


	dispatch def String generateSQLStatement(Statement statement) ''''''
	
	dispatch def String generateSQLStatement(CreateTableStatement statement) '''
    CREATE TABLE «statement.table.name.toFirstUpper»(
        «FOR column:statement.columns.columnItem»
            «column.name.toFirstUpper» «column.type.toSqlString»,
        «ENDFOR»
    );'''

	dispatch def String generateSQLStatement(SelectStatement statement) '''
	SELECT«IF statement.columns === null»«" *\n"»«ELSE»«FOR column : statement.columns.selectColumn» «column.column.name.toFirstUpper»«IF !column.equals(statement.columns.selectColumn.last)»,«ENDIF»«ENDFOR»«ENDIF»
	FROM «statement.tables.selectTable.map[name.toFirstUpper].join(', ')»
	«IF statement.condition !== null»WHERE «statement.condition.generateConditionExpression»«ENDIF»
	«IF statement.group === null»;«ELSE»GROUP BY «statement.group.selectColumn.map[column.name.toFirstUpper].join(', ')»;«ENDIF»
	'''
	
	dispatch def generateSQLStatement(InsertStatement statement) '''
	INSERT INTO «statement.table.table.name.toFirstUpper» («FOR column : statement.columns.selectColumn»«column.column.name.toFirstUpper»«IF !column.equals(statement.columns.selectColumn.last)», «ENDIF»«ENDFOR»)
	VALUES («FOR value : statement.values.valueList»«value»«IF !value.equals(statement.values.valueList.last)», «ENDIF»«ENDFOR»)
	;
	'''
	
	dispatch def generateSQLStatement(UpdateStatement statement) '''
	UPDATE «statement.table.table.name.toFirstUpper»
	SET «FOR update : statement.updates.updateItem»«update.column.column.name.toFirstUpper» = «update.value»«IF !update.equals(statement.updates.updateItem.last)», «ENDIF»«ENDFOR»
	«IF statement.condition !== null»WHERE «statement.condition.generateConditionExpression»«ENDIF»
	;
	'''
	
	dispatch def generateSQLStatement(DeleteStatement statement) '''
	«IF statement.tableToEmpty !== null»DELETE FROM «statement.tableToEmpty.table.name.toFirstUpper»«ELSE»«IF statement.tables !== null»DROP TABLE «statement.tables.selectTable.map[name.toFirstUpper].join(",")»«ELSE»DELETE FROM «statement.tableToDelete.table.name.toFirstUpper»
	WHERE «statement.condition.generateConditionExpression»«ENDIF»«ENDIF»
	;
	'''

	def toSqlString(Datatype datatype) '''
    «switch datatype {
        case Datatype.INTEGER: "INT"
        case Datatype.STRING: "VARCHAR(255)"
        case Datatype.DATE: "DATE"
    }»'''

	dispatch def String generateConditionExpression(LogicExpressions expression) ''''''
	dispatch def String generateConditionExpression(Condition expression) '''
	«expression.left.generateConditionExpression»«FOR logicOperatorIndex: (0..expression.logicOperator.size-1)» «expression.logicOperator.get(logicOperatorIndex)» «expression.right.get(logicOperatorIndex).generateConditionExpression»«ENDFOR»'''
	dispatch def String generateConditionExpression(Comparison expression) '''
	«expression.leftHandSide.name.toFirstUpper» «expression.operator.generateComparisonOperatorExpression» «expression.rightHandSide»'''
	def String generateComparisonOperatorExpression(ComparisonOperatorString comparison) '''
	«switch comparison {
	        case EQUAL_TO: "="
	        case LESS_THAN: "<"
	        case GREATER_THAN: ">"
	        case LESS_THAN_OR_EQUAL_TO: "<="
	        case GREATER_THEN_OR_EQUAL_TO: ">="
	        case NOT_EQUAL_TO: "<>"
	        case EQUAL_TO_SIGN: "="
			case GREATER_THAN_SIGN: ">"
			case GREATER_THEN_OR_EQUAL_TO_SIGN: ">="
			case LESS_THAN_OR_EQUAL_TO_SIGN: "<="
			case LESS_THAN_SIGN:"<="
			case NOT_EQUAL_TO_SIGN:"<>"	        
	    }»'''

	def deriveClassName(Resource resource) {
		val originalFileName = resource.URI.lastSegment
		originalFileName.substring(0,originalFileName.indexOf('.')).toFirstUpper + 'AccountingSpeech'
	}
	
	
	def deriveTargetFileNameFor(AccountingSpeech speech, Resource resource) {
		resource.URI.appendFileExtension('sql').lastSegment
	}
}
