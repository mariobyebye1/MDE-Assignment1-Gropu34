/*
 * generated by Xtext 2.25.0
 */
package uk.ac.kcl.inf.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.inf.nlToSql.AccountingSpeech;
import uk.ac.kcl.inf.nlToSql.Column;
import uk.ac.kcl.inf.nlToSql.ColumnList;
import uk.ac.kcl.inf.nlToSql.ColumnReference;
import uk.ac.kcl.inf.nlToSql.Comparison;
import uk.ac.kcl.inf.nlToSql.CreateTableStatement;
import uk.ac.kcl.inf.nlToSql.InserValues;
import uk.ac.kcl.inf.nlToSql.LogicExpressions;
import uk.ac.kcl.inf.nlToSql.NlToSqlPackage;
import uk.ac.kcl.inf.nlToSql.SelectColumnsList;
import uk.ac.kcl.inf.nlToSql.SelectTable;
import uk.ac.kcl.inf.nlToSql.SelectTablesList;
import uk.ac.kcl.inf.nlToSql.SelectUpdateList;
import uk.ac.kcl.inf.nlToSql.Table;
import uk.ac.kcl.inf.nlToSql.UpdateItem;
import uk.ac.kcl.inf.services.NlToSqlGrammarAccess;

@SuppressWarnings("all")
public class NlToSqlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private NlToSqlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == NlToSqlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case NlToSqlPackage.ACCOUNTING_SPEECH:
				sequence_AccountingSpeech(context, (AccountingSpeech) semanticObject); 
				return; 
			case NlToSqlPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case NlToSqlPackage.COLUMN_LIST:
				sequence_ColumnList(context, (ColumnList) semanticObject); 
				return; 
			case NlToSqlPackage.COLUMN_REFERENCE:
				sequence_ColumnReference(context, (ColumnReference) semanticObject); 
				return; 
			case NlToSqlPackage.COMPARISON:
				sequence_Condition(context, (Comparison) semanticObject); 
				return; 
			case NlToSqlPackage.CREATE_TABLE_STATEMENT:
				sequence_CreateTableStatement(context, (CreateTableStatement) semanticObject); 
				return; 
			case NlToSqlPackage.INSER_VALUES:
				sequence_InserValues(context, (InserValues) semanticObject); 
				return; 
			case NlToSqlPackage.LOGIC_EXPRESSIONS:
				sequence_Comparison(context, (LogicExpressions) semanticObject); 
				return; 
			case NlToSqlPackage.SELECT_COLUMNS_LIST:
				sequence_SelectColumnsList(context, (SelectColumnsList) semanticObject); 
				return; 
			case NlToSqlPackage.SELECT_TABLE:
				if (rule == grammarAccess.getStatementRule()) {
					sequence_DeleteStatement_InsertStatement_SelectTable_UpdateStatement(context, (SelectTable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeleteStatementRule()) {
					sequence_DeleteStatement_SelectTable(context, (SelectTable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInsertStatementRule()) {
					sequence_InsertStatement_SelectTable(context, (SelectTable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSelectTableRule()) {
					sequence_SelectTable(context, (SelectTable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUpdateStatementRule()) {
					sequence_SelectTable_UpdateStatement(context, (SelectTable) semanticObject); 
					return; 
				}
				else break;
			case NlToSqlPackage.SELECT_TABLES_LIST:
				if (rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getSelectStatementRule()) {
					sequence_SelectStatement_SelectTablesList(context, (SelectTablesList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSelectTablesListRule()) {
					sequence_SelectTablesList(context, (SelectTablesList) semanticObject); 
					return; 
				}
				else break;
			case NlToSqlPackage.SELECT_UPDATE_LIST:
				sequence_SelectUpdateList(context, (SelectUpdateList) semanticObject); 
				return; 
			case NlToSqlPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case NlToSqlPackage.UPDATE_ITEM:
				sequence_UpdateItem(context, (UpdateItem) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AccountingSpeech returns AccountingSpeech
	 *
	 * Constraint:
	 *     statements+=Statement+
	 */
	protected void sequence_AccountingSpeech(ISerializationContext context, AccountingSpeech semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnList returns ColumnList
	 *
	 * Constraint:
	 *     (columnItem+=Column columnItem+=Column*)
	 */
	protected void sequence_ColumnList(ISerializationContext context, ColumnList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ColumnReference returns ColumnReference
	 *
	 * Constraint:
	 *     (column=[Column|ID] table=[Table|ID]?)
	 */
	protected void sequence_ColumnReference(ISerializationContext context, ColumnReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (name=ID type=Datatype)
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.COLUMN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.COLUMN__NAME));
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.COLUMN__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.COLUMN__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getColumnAccess().getTypeDatatypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns LogicExpressions
	 *     Condition.Comparison_1_0 returns LogicExpressions
	 *     Comparison returns LogicExpressions
	 *
	 * Constraint:
	 *     (leftHandSide=[Column|ID] operator=ComparisonOperator rightHandSide=Value)
	 */
	protected void sequence_Comparison(ISerializationContext context, LogicExpressions semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.LOGIC_EXPRESSIONS__LEFT_HAND_SIDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.LOGIC_EXPRESSIONS__LEFT_HAND_SIDE));
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.LOGIC_EXPRESSIONS__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.LOGIC_EXPRESSIONS__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.LOGIC_EXPRESSIONS__RIGHT_HAND_SIDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.LOGIC_EXPRESSIONS__RIGHT_HAND_SIDE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getLeftHandSideColumnIDTerminalRuleCall_1_0_1(), semanticObject.eGet(NlToSqlPackage.Literals.LOGIC_EXPRESSIONS__LEFT_HAND_SIDE, false));
		feeder.accept(grammarAccess.getComparisonAccess().getOperatorComparisonOperatorParserRuleCall_2_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getComparisonAccess().getRightHandSideValueParserRuleCall_3_0(), semanticObject.getRightHandSide());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Comparison
	 *     Condition.Comparison_1_0 returns Comparison
	 *
	 * Constraint:
	 *     (left=Condition_Comparison_1_0 right+=Comparison)
	 */
	protected void sequence_Condition(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CreateTableStatement
	 *     CreateTableStatement returns CreateTableStatement
	 *
	 * Constraint:
	 *     (table=Table columns=ColumnList?)
	 */
	protected void sequence_CreateTableStatement(ISerializationContext context, CreateTableStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SelectTable
	 *
	 * Constraint:
	 *     (table=[Table|ID] ((columns=SelectColumnsList values=InserValues) | (updates=SelectUpdateList condition=Condition?) | condition=Condition)?)
	 */
	protected void sequence_DeleteStatement_InsertStatement_SelectTable_UpdateStatement(ISerializationContext context, SelectTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeleteStatement returns SelectTable
	 *
	 * Constraint:
	 *     (table=[Table|ID] condition=Condition?)
	 */
	protected void sequence_DeleteStatement_SelectTable(ISerializationContext context, SelectTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InserValues returns InserValues
	 *
	 * Constraint:
	 *     (valueList+=Value valueList+=Value*)
	 */
	protected void sequence_InserValues(ISerializationContext context, InserValues semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InsertStatement returns SelectTable
	 *
	 * Constraint:
	 *     (table=[Table|ID] columns=SelectColumnsList values=InserValues)
	 */
	protected void sequence_InsertStatement_SelectTable(ISerializationContext context, SelectTable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.SELECT_TABLE__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.SELECT_TABLE__TABLE));
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.SELECT_TABLE__COLUMNS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.SELECT_TABLE__COLUMNS));
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.SELECT_TABLE__VALUES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.SELECT_TABLE__VALUES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectTableAccess().getTableTableIDTerminalRuleCall_0_1(), semanticObject.eGet(NlToSqlPackage.Literals.SELECT_TABLE__TABLE, false));
		feeder.accept(grammarAccess.getInsertStatementAccess().getColumnsSelectColumnsListParserRuleCall_8_0(), semanticObject.getColumns());
		feeder.accept(grammarAccess.getInsertStatementAccess().getValuesInserValuesParserRuleCall_13_0(), semanticObject.getValues());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SelectColumnsList returns SelectColumnsList
	 *
	 * Constraint:
	 *     (selectColumn+=ColumnReference selectColumn+=ColumnReference*)
	 */
	protected void sequence_SelectColumnsList(ISerializationContext context, SelectColumnsList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SelectTablesList
	 *     SelectStatement returns SelectTablesList
	 *
	 * Constraint:
	 *     (selectTable+=[Table|ID] selectTable+=[Table|ID]* columns=SelectColumnsList? condition=Condition? group=SelectColumnsList?)
	 */
	protected void sequence_SelectStatement_SelectTablesList(ISerializationContext context, SelectTablesList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectTable returns SelectTable
	 *
	 * Constraint:
	 *     table=[Table|ID]
	 */
	protected void sequence_SelectTable(ISerializationContext context, SelectTable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.SELECT_TABLE__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.SELECT_TABLE__TABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectTableAccess().getTableTableIDTerminalRuleCall_0_1(), semanticObject.eGet(NlToSqlPackage.Literals.SELECT_TABLE__TABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UpdateStatement returns SelectTable
	 *
	 * Constraint:
	 *     (table=[Table|ID] updates=SelectUpdateList condition=Condition?)
	 */
	protected void sequence_SelectTable_UpdateStatement(ISerializationContext context, SelectTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectTablesList returns SelectTablesList
	 *
	 * Constraint:
	 *     (selectTable+=[Table|ID] selectTable+=[Table|ID]*)
	 */
	protected void sequence_SelectTablesList(ISerializationContext context, SelectTablesList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectUpdateList returns SelectUpdateList
	 *
	 * Constraint:
	 *     (updateItem+=UpdateItem updateItem+=UpdateItem*)
	 */
	protected void sequence_SelectUpdateList(ISerializationContext context, SelectUpdateList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.TABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.TABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UpdateItem returns UpdateItem
	 *
	 * Constraint:
	 *     (column=ColumnReference value=Value)
	 */
	protected void sequence_UpdateItem(ISerializationContext context, UpdateItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.UPDATE_ITEM__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.UPDATE_ITEM__COLUMN));
			if (transientValues.isValueTransient(semanticObject, NlToSqlPackage.Literals.UPDATE_ITEM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NlToSqlPackage.Literals.UPDATE_ITEM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateItemAccess().getColumnColumnReferenceParserRuleCall_0_0(), semanticObject.getColumn());
		feeder.accept(grammarAccess.getUpdateItemAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
